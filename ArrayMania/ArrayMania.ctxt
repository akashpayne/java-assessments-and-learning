#BlueJ class context
comment0.params=length\ inversions
comment0.target=int[]\ inversionGeneratorA(int,\ int)
comment0.text=\r\n\ Answer\ to\ Question\ 3a\:\ \r\n\ The\ inversion\ Generator\ A\ method,\ generates\ an\ arbitrary\ int\ array,\ randomArray,\ of\ length,\ length,\r\n\ and\ unsorts\ the\ array\ to\ a\ specified\ upfront\ amount\ of\ inversions,\ inversions.\ The\ time\ complexity\ \r\n\ of\ this\ implementation\ is\ generate\ and\ test,\ i.e.\ exhaustive\ search\ that\ consists\ of\ systematically\r\n\ list\ all\ possible\ items\ for\ the\ solution\ and\ check\ whether\ each\ candidate\ statisfies\ the\ problem\r\n\ statement.\ Therefore,\ we\ can\ say\ that\ the\ implementation\ is\ Linear,\ O(n),\ i.e.\ the\ time\ complexity\ \r\n\ for\ searching\ when\ compared\ with\ data\ structures\ such\ as\ a\ sorted\ array\ of\ n\ element;\ its\r\n\ cost\ is\ proportional\ to\ the\ number\ of\ candidate\ solutions.\ (Brute\ force).\ \r\n\ The\ maximum\ number\ of\ inversions\ in\ an\ array\ of\ n\ *\ elements\ is\ n\u22C5(n-1)2.\r\n\ This\ shows\ that\ the\ number\ of\ elements\ in\ the\ array\ and\ the\ number\ of\ inversions\ in\ the\ array\ are\r\n\ both\ proportional\ to\ the\ time\ complexity\ of\ the\ implementation.\ \r\n
comment1.params=array
comment1.target=int[]\ aSort(int[])
comment2.params=array\ inversions
comment2.target=int[]\ bSort(int[],\ int)
comment3.params=array
comment3.target=int[]\ shuffleArray(int[])
comment4.params=array
comment4.target=int[]\ nextPermutation(int[])
comment5.params=length\ inversions
comment5.target=int[]\ inversionGeneratorI(int,\ int)
comment5.text=\r\n\ Answer\ to\ Question\ 3b\:\ \r\n\ The\ inversion\ Generator\ A\ method,\ generates\ an\ arbitrary\ int\ array,\ randomArray,\ of\ length,\ length,\r\n\ and\ unsorts\ the\ array\ to\ a\ specified\ upfront\ amount\ of\ inversions,\ inversions.\ The\ time\ complexity\ \r\n\ of\ this\ implementation\ reflects\ the\ shuffle\ of\ all\ the\ elements\ in\ the\ array\ and\ is\ proportional\ to\r\n\ the\ size\ of\ the\ array\ and\ the\ number\ of\ inversions,\ i.e.\ exhaustive\ search\ that\ consists\ of\ \r\n\ systematically\ list\ all\ possible\ items\ for\ the\ solution\ and\ check\ whether\ each\ candidate\ statisfies\ \r\n\ the\ problem\ statement.\ Therefore,\ we\ can\ say\ that\ the\ implementation\ is\ Linear,\ O(n),\ i.e.\ the\ time\ \r\n\ complexity\ for\ searching\ when\ compared\ with\ data\ structures\ such\ as\ a\ sorted\ array\ of\ n\ element;\ \r\n\ its\ cost\ is\ proportional\ to\ the\ number\ of\ candidate\ solutions.\ (Brute\ force).\ \r\n\ The\ maximum\ number\ of\ inversions\ in\ an\ array\ of\ n\ *\ elements\ is\ n\u22C5(n-1)2.\ This\ shows\ that\ the\ number\ \r\n\ of\ elements\ in\ the\ array\ and\ the\ number\ of\ inversions\ in\ the\ array\ are\ both\ proportional\ to\ the\ time\ \r\n\ complexity\ of\ the\ implementation.\ \r\n\ \r\n\ After\ trying\ to\ make\ the\ generator\ more\ efficient\ with\ a\ quicksort\ or\ mergesort,\ to\ the\ split\ case\ \r\n\ the\ array,\ I\ found\ that\ the\ shuffle\ method\ was\ more\ efficient\ for\ generating\ smaller\ arrays\ with\ \r\n\ inversions.\ \ \r\n
comment6.params=array
comment6.target=int\ inversionCount(int[])
comment6.text=\r\n\ given\ method\r\n\ @param\ array\:\ any\ array\ of\ integers\r\n\ @return\ the\ number\ of\ inversions\ in\ that\ array\r\n
comment7.params=length\ sortedness
comment7.target=int[]\ inversionGeneratorD(int,\ double)
comment7.text=\r\n\ A\ method\ int[]\ inversionGeneratorD(int\ length,double\ sortedness)\ that\ generates\ an\ int\ \r\n\ array\ of\ length\ length\ whose\ sortedness\ is\ measured\ by\ the\ floating\ point\ number\ \r\n\ sortedness.\ This\ number\ should\ be\ between\ -1.0\ (reverse\ order)\ and\ 1.0\ (sorted\ order),\ \r\n\ with\ the\ numbers\ in\ between\ scaled\ by\ the\ number\ of\ inversions\ the\ array\ has\ (relative\ to\ \r\n\ how\ many\ it\ could\ have).\ Essentially\ this\ method\ should\ reduce\ its\ work\ to\ \r\n\ inversionGeneratorI,\ and\ throw\ a\ \ WrongInversionException\ if\ sortedness\ is\ out\ of\ bounds.\r\n\ Pearson's\ correlation\ coefficient\:\r\n\ --\ r\ \=\ 1/(n-1)\ *\ sumOfEach(x\ element\ -\ x\ mean)/standardDeviation\ for\ X\ *\ sumOfEach(y\ element\ \r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -\ y\ mean)/y\ standard\ deviation\ \r\n\ or\ scale\ -1\ to\ 1\ ...\ -1\ \=\ 0%\ sorted;\ 1\ \=\ 100%\ sorted.\r\n\ sortedness\:\ get\ a\ ratio\ for\ -1\:1\ and\ then\ multiple\ the\ max\ \#\ of\ inversions\ to\ get\ inversions.\ \r\n
numComments=8
